use crate::codegen::model::{ExportedEnum, ExportedRecord, ExportedTypes};
use crate::codegen::writer::CodeWriter;
use nx_hir::ast::TypeRef;

pub fn emit_typescript(writer: &mut CodeWriter, types: &ExportedTypes) {
    writer.line("// <auto-generated/>");
    writer.line("// Generated by nxlang");
    writer.blank_line();

    for (idx, en) in types.enums.iter().enumerate() {
        emit_enum(writer, en);
        if idx + 1 != types.enums.len() || !types.records.is_empty() {
            writer.blank_line();
        }
    }

    for (idx, record) in types.records.iter().enumerate() {
        emit_record(writer, record);
        if idx + 1 != types.records.len() {
            writer.blank_line();
        }
    }
}

fn emit_enum(writer: &mut CodeWriter, en: &ExportedEnum) {
    // Prefer a string literal union to avoid emitting runtime JS.
    let mut parts = Vec::new();
    for member in &en.members {
        parts.push(format!("\"{}\"", escape_ts_string(member)));
    }
    let rhs = if parts.is_empty() {
        "never".to_string()
    } else {
        parts.join(" | ")
    };

    writer.line(&format!(
        "export type {} = {};",
        sanitize_ts_type_name(&en.name),
        rhs
    ));
}

fn emit_record(writer: &mut CodeWriter, record: &ExportedRecord) {
    writer.block(
        &format!("export interface {}", sanitize_ts_type_name(&record.name)),
        |writer| {
            for field in &record.fields {
                let key = ts_property_key(&field.name);
                let ty = ts_type(&field.ty);
                writer.line(&format!("{key}: {ty};"));
            }
        },
    );
}

fn ts_type(ty: &TypeRef) -> String {
    match ty {
        TypeRef::Name(name) => ts_type_name(name.as_str()),
        TypeRef::Array(inner) => {
            let inner = ts_type(inner);
            let needs_parens = matches!(inner.as_str(), s if s.contains('|') || s.contains("=>"));
            if needs_parens {
                format!("({inner})[]")
            } else {
                format!("{inner}[]")
            }
        }
        TypeRef::Nullable(inner) => format!("{} | null", ts_type(inner)),
        TypeRef::Function {
            params,
            return_type,
        } => {
            let mut parts = Vec::new();
            for (idx, param) in params.iter().enumerate() {
                parts.push(format!("arg{idx}: {}", ts_type(param)));
            }
            format!("({}) => {}", parts.join(", "), ts_type(return_type))
        }
    }
}

fn ts_type_name(name: &str) -> String {
    match name {
        "string" => "string".to_string(),
        "i32" | "i64" | "int" | "f32" | "f64" | "float" => "number".to_string(),
        "boolean" => "boolean".to_string(),
        "void" => "void".to_string(),
        "object" => "unknown".to_string(),
        other => other.to_string(),
    }
}

fn ts_property_key(name: &str) -> String {
    if is_ts_identifier(name) {
        name.to_string()
    } else {
        format!("\"{}\"", escape_ts_string(name))
    }
}

fn is_ts_identifier(s: &str) -> bool {
    let mut chars = s.chars();
    let Some(first) = chars.next() else {
        return false;
    };

    if !(first == '_' || first == '$' || first.is_ascii_alphabetic()) {
        return false;
    }

    for ch in chars {
        if !(ch == '_' || ch == '$' || ch.is_ascii_alphanumeric()) {
            return false;
        }
    }

    true
}

fn sanitize_ts_type_name(name: &str) -> String {
    let mut out = String::new();
    for (idx, ch) in name.chars().enumerate() {
        let ok = if idx == 0 {
            ch == '_' || ch == '$' || ch.is_ascii_alphabetic()
        } else {
            ch == '_' || ch == '$' || ch.is_ascii_alphanumeric()
        };
        out.push(if ok { ch } else { '_' });
    }

    if out.is_empty() {
        "_".to_string()
    } else if out.chars().next().unwrap().is_ascii_digit() {
        format!("_{out}")
    } else {
        out
    }
}

fn escape_ts_string(s: &str) -> String {
    s.replace('\\', "\\\\").replace('\"', "\\\"")
}
