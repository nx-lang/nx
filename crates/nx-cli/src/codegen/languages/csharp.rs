use crate::codegen::model::{ExportedEnum, ExportedRecord, ExportedTypes};
use crate::codegen::writer::CodeWriter;
use nx_hir::ast::TypeRef;

pub fn emit_csharp(writer: &mut CodeWriter, ns: &str, types: &ExportedTypes) {
    writer.line("// <auto-generated/>");
    writer.line("// Generated by nxlang");
    writer.line("#nullable enable");
    writer.blank_line();

    writer.line("using System;");
    writer.blank_line();

    writer.block(
        &format!("namespace {}", sanitize_csharp_qualified_name(ns)),
        |writer| {
            for (idx, en) in types.enums.iter().enumerate() {
                emit_enum(writer, en);
                if idx + 1 != types.enums.len() || !types.records.is_empty() {
                    writer.blank_line();
                }
            }

            for (idx, record) in types.records.iter().enumerate() {
                emit_record(writer, record);
                if idx + 1 != types.records.len() {
                    writer.blank_line();
                }
            }
        },
    );
}

fn emit_enum(writer: &mut CodeWriter, en: &ExportedEnum) {
    writer.block(
        &format!("public enum {}", sanitize_csharp_identifier(&en.name)),
        |writer| {
            for (idx, member) in en.members.iter().enumerate() {
                let comma = if idx + 1 == en.members.len() { "" } else { "," };
                writer.line(&format!("{}{}", sanitize_csharp_identifier(member), comma));
            }
        },
    );
}

fn emit_record(writer: &mut CodeWriter, record: &ExportedRecord) {
    writer.block(
        &format!(
            "public sealed class {}",
            sanitize_csharp_identifier(&record.name)
        ),
        |writer| {
            for field in &record.fields {
                let cs_type = csharp_type(&field.ty);
                let name = sanitize_csharp_identifier(&field.name);

                if cs_type.is_reference && !cs_type.is_nullable {
                    writer.line(&format!(
                        "public {} {} {{ get; set; }} = default!;",
                        cs_type.text, name
                    ));
                } else {
                    writer.line(&format!("public {} {} {{ get; set; }}", cs_type.text, name));
                }
            }
        },
    );
}

#[derive(Clone, Debug)]
struct CSharpType {
    text: String,
    is_reference: bool,
    is_nullable: bool,
}

fn csharp_type(ty: &TypeRef) -> CSharpType {
    match ty {
        TypeRef::Nullable(inner) => {
            let mut inner = csharp_type(inner);
            inner.text = format!("{}?", inner.text);
            inner.is_nullable = true;
            inner
        }
        TypeRef::Array(inner) => {
            let inner = csharp_type(inner);
            CSharpType {
                text: format!("{}[]", inner.text),
                is_reference: true,
                is_nullable: false,
            }
        }
        TypeRef::Function { .. } => CSharpType {
            text: "Delegate".to_string(),
            is_reference: true,
            is_nullable: false,
        },
        TypeRef::Name(name) => csharp_type_name(name.as_str()),
    }
}

fn csharp_type_name(name: &str) -> CSharpType {
    match name {
        "string" => CSharpType {
            text: "string".to_string(),
            is_reference: true,
            is_nullable: false,
        },
        "int" => CSharpType {
            text: "int".to_string(),
            is_reference: false,
            is_nullable: false,
        },
        "long" => CSharpType {
            text: "long".to_string(),
            is_reference: false,
            is_nullable: false,
        },
        "float" => CSharpType {
            text: "float".to_string(),
            is_reference: false,
            is_nullable: false,
        },
        "double" => CSharpType {
            text: "double".to_string(),
            is_reference: false,
            is_nullable: false,
        },
        "boolean" => CSharpType {
            text: "bool".to_string(),
            is_reference: false,
            is_nullable: false,
        },
        "void" => CSharpType {
            text: "void".to_string(),
            is_reference: false,
            is_nullable: false,
        },
        "object" | "unknown" | "error" => CSharpType {
            text: "object".to_string(),
            is_reference: true,
            is_nullable: false,
        },
        other => CSharpType {
            text: sanitize_csharp_qualified_name(other),
            is_reference: true,
            is_nullable: false,
        },
    }
}

fn sanitize_csharp_qualified_name(name: &str) -> String {
    name.split('.')
        .filter(|part| !part.is_empty())
        .map(sanitize_csharp_identifier)
        .collect::<Vec<_>>()
        .join(".")
}

fn sanitize_csharp_identifier(name: &str) -> String {
    let mut out = String::new();
    for (idx, ch) in name.chars().enumerate() {
        let ok = if idx == 0 {
            ch == '_' || ch.is_ascii_alphabetic()
        } else {
            ch == '_' || ch.is_ascii_alphanumeric()
        };
        out.push(if ok { ch } else { '_' });
    }

    if out.is_empty() {
        out.push('_');
    }
    if out.chars().next().unwrap().is_ascii_digit() {
        out.insert(0, '_');
    }

    if is_csharp_keyword(&out) {
        format!("@{out}")
    } else {
        out
    }
}

fn is_csharp_keyword(s: &str) -> bool {
    matches!(
        s,
        "abstract"
            | "as"
            | "base"
            | "bool"
            | "break"
            | "byte"
            | "case"
            | "catch"
            | "char"
            | "checked"
            | "class"
            | "const"
            | "continue"
            | "decimal"
            | "default"
            | "delegate"
            | "do"
            | "double"
            | "else"
            | "enum"
            | "event"
            | "explicit"
            | "extern"
            | "false"
            | "finally"
            | "fixed"
            | "float"
            | "for"
            | "foreach"
            | "goto"
            | "if"
            | "implicit"
            | "in"
            | "int"
            | "interface"
            | "internal"
            | "is"
            | "lock"
            | "long"
            | "namespace"
            | "new"
            | "null"
            | "object"
            | "operator"
            | "out"
            | "override"
            | "params"
            | "private"
            | "protected"
            | "public"
            | "readonly"
            | "ref"
            | "return"
            | "sbyte"
            | "sealed"
            | "short"
            | "sizeof"
            | "stackalloc"
            | "static"
            | "string"
            | "struct"
            | "switch"
            | "this"
            | "throw"
            | "true"
            | "try"
            | "typeof"
            | "uint"
            | "ulong"
            | "unchecked"
            | "unsafe"
            | "ushort"
            | "using"
            | "virtual"
            | "void"
            | "volatile"
            | "while"
    )
}
