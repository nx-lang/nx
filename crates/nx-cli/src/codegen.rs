mod editorconfig;
mod languages;
mod model;
pub mod options;
mod writer;

use crate::codegen::options::FormatOptions;
use crate::codegen::writer::CodeWriter;
use nx_hir::Module;
use std::path::Path;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum TargetLanguage {
    CSharp,
    TypeScript,
}

#[derive(Clone, Debug)]
pub struct GenerateTypesOptions {
    pub language: TargetLanguage,
    pub csharp_namespace: Option<String>,
    pub format: FormatOptions,
}

pub fn format_options_from_editorconfig(
    language: TargetLanguage,
    editorconfig_path: &Path,
    target_file_name: &str,
) -> Result<FormatOptions, String> {
    let config = editorconfig::EditorConfig::parse_file(editorconfig_path)?;
    let mut opts = FormatOptions::defaults_for(language);
    config.apply_to(&mut opts, language, target_file_name);
    Ok(opts)
}

pub fn generate_types(module: &Module, opts: &GenerateTypesOptions) -> Result<String, String> {
    let exported = model::collect_exported_types(module);

    let mut writer = CodeWriter::new(opts.format.clone());
    match opts.language {
        TargetLanguage::TypeScript => {
            languages::typescript::emit_typescript(&mut writer, &exported)
        }
        TargetLanguage::CSharp => {
            let ns = opts.csharp_namespace.as_deref().unwrap_or("Nx.Generated");
            languages::csharp::emit_csharp(&mut writer, ns, &exported)
        }
    }
    Ok(writer.finish())
}

#[cfg(test)]
mod tests {
    use super::*;
    use nx_hir::{lower, SourceId};
    use nx_syntax::parse_str;
    use tempfile::NamedTempFile;

    #[test]
    fn generates_typescript_records_and_enums() {
        let source = r#"
            enum Direction = | North | South
            type User = { name: string age: int }
        "#;
        let parse_result = parse_str(source, "types.nx");
        let tree = parse_result.tree.expect("expected parse tree");
        let module = lower(tree.root(), SourceId::new(0));

        let opts = GenerateTypesOptions {
            language: TargetLanguage::TypeScript,
            csharp_namespace: None,
            format: options::FormatOptions::defaults_for(TargetLanguage::TypeScript),
        };

        let out = generate_types(&module, &opts).unwrap();
        let nl = opts.format.newline_str();
        let expected = vec![
            "// <auto-generated/>",
            "// Generated by nxlang",
            "",
            "export type Direction = \"North\" | \"South\";",
            "",
            "export interface User {",
            "  name: string;",
            "  age: number;",
            "}",
            "",
        ]
        .join(nl);
        assert_eq!(out, expected);
    }

    #[test]
    fn generates_csharp_with_editorconfig_formatting() {
        let source = r#"
            enum Direction = | North | South
            type User = { name: string age: int }
        "#;
        let parse_result = parse_str(source, "types.nx");
        let tree = parse_result.tree.expect("expected parse tree");
        let module = lower(tree.root(), SourceId::new(0));

        let mut tmp = NamedTempFile::new().unwrap();
        std::io::Write::write_all(
            &mut tmp,
            br#"
                [*]
                indent_style = tab

                [*.cs]
                csharp_new_line_before_open_brace = none
            "#,
        )
        .unwrap();

        let format =
            format_options_from_editorconfig(TargetLanguage::CSharp, tmp.path(), "Types.g.cs")
                .unwrap();

        let opts = GenerateTypesOptions {
            language: TargetLanguage::CSharp,
            csharp_namespace: Some("Test.Namespace".to_string()),
            format,
        };

        let out = generate_types(&module, &opts).unwrap();
        assert!(out.contains("namespace Test.Namespace {"));
        assert!(out.contains("\tpublic enum Direction {"));
        assert!(out.contains("\tpublic sealed class User {"));
    }
}
