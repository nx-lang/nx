# Implementation Plan: Core NX Parsing and Validation

**Branch**: `001-nx-core-parsing` | **Date**: 2025-10-26 | **Spec**: [spec.md](./spec.md)

## Summary

Implement the core Rust-based parsing and type checking library for the NX language. This feature focuses on building a thread-safe, performant library API that parses NX source files into a Concrete Syntax Tree (CST), performs semantic analysis, and executes type checking with inference. The implementation excludes CLI and IDE integration, which will be separate features.

**Key Technical Approach**:
- tree-sitter for parsing (CST layer)
- Rust HIR for semantic analysis (AST layer)
- Salsa for incremental computation
- Ariadne for beautiful error diagnostics
- Thread-safe library API supporting concurrent file processing

## Technical Context

**Language/Version**: Rust 1.75+
**Primary Dependencies**: tree-sitter 0.20+, salsa 0.16+, ariadne 0.4, text-size 1.1+
**Storage**: In-memory (CST, HIR, type environment); incremental caching via Salsa
**Testing**: cargo test, insta for snapshot testing
**Target Platform**: Library (Linux, macOS, Windows); future FFI bindings for .NET/Node.js
**Project Type**: Rust workspace with multiple crates (nx-diagnostics, nx-syntax, nx-hir, nx-types)
**Performance Goals**:
  - Parsing: >10,000 lines/second
  - Type checking: <2 seconds for 10,000-line files
  - Memory: <100MB for 10,000-line files
**Constraints**:
  - Thread-safe concurrent parsing
  - Best-effort error recovery within scopes
  - UTF-8 only file encoding
  - Local type inference (variables/expressions/returns), explicit parameters
**Scale/Scope**:
  - 4 core Rust crates (~10-15k LOC total)
  - Support NX grammar (elements, properties, expressions, functions, types)
  - Comprehensive diagnostic system with source context

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Quality Gates Analysis

| Gate | Status | Notes |
|------|--------|-------|
| **Build: cargo build --workspace** | ✅ PASS | Existing workspace builds successfully |
| **Format: cargo fmt --all --check** | ✅ PASS | Code follows rustfmt standards |
| **Lint: cargo clippy --workspace** | ✅ PASS | Zero warnings policy enforced |
| **Tests: cargo test --workspace** | ✅ PASS | All tests must pass before merge |
| **Documentation: cargo doc --workspace** | ✅ PASS | Public APIs documented with rustdoc |
| **Manual Review** | ⏳ PENDING | Code review required for all PRs |

### Principle Compliance

**I. Code Quality First** - ✅ COMPLIANT
- Rust's explicit typing naturally enforces "explicit over implicit"
- `cargo fmt` provides consistent formatting (4-space indent)
- All public APIs will have `///` doc comments
- No warnings policy via clippy
- Naming: snake_case functions/variables, PascalCase types (Rust standard)

**II. Comprehensive Testing** - ✅ COMPLIANT
- Unit tests inline with code (`#[cfg(test)] mod tests`)
- Integration tests in `tests/` directories
- Snapshot tests with `insta` for parser regression testing
- Tests committed alongside implementation
- Bug fixes include regression tests

**III. User Experience Consistency** - ✅ COMPLIANT
- Error messages use `nx-diagnostics` crate with Ariadne
- Performance targets documented (<1s parsing, <2s type checking)
- API will provide both parse results and rich diagnostics
- Documentation with examples required for all public APIs

### Complexity Justification

No constitution violations. Architecture follows industry-standard patterns (rust-analyzer, SWC) with clear separation of concerns across multiple crates.

## Project Structure

### Documentation (this feature)

```text
specs/001-nx-core-parsing/
├── spec.md              # Feature specification
├── plan.md              # This file (/speckit.plan output)
├── research.md          # Phase 0: Research findings (below)
├── data-model.md        # Phase 1: Data structures & entities (below)
├── quickstart.md        # Phase 1: Developer quick start (below)
├── contracts/           # Phase 1: Public API contracts
│   └── library-api.md   # Rust library API surface
├── checklists/
│   └── requirements.md  # Spec validation checklist
└── tasks.md             # Phase 2: Generated by /speckit.tasks
```

### Source Code (existing Rust workspace)

```text
crates/
├── nx-diagnostics/      # Leaf crate: Error formatting with Ariadne
│   ├── Cargo.toml
│   ├── src/
│   │   ├── lib.rs       # Public API + unit tests
│   │   ├── diagnostic.rs # Diagnostic types
│   │   └── render.rs    # Ariadne formatting
│   └── tests/
│       └── render_tests.rs
│
├── nx-syntax/           # CST + tree-sitter parser
│   ├── Cargo.toml
│   ├── build.rs         # Compiles tree-sitter grammar
│   ├── grammar.js       # tree-sitter grammar definition
│   ├── src/
│   │   ├── lib.rs       # Public API + unit tests
│   │   ├── syntax_kind.rs   # Token/node type enums
│   │   ├── syntax_node.rs   # Typed CST wrappers
│   │   ├── ast.rs       # CST traversal helpers
│   │   └── validation.rs    # Post-parse validation
│   ├── queries/         # tree-sitter queries
│   │   ├── highlights.scm
│   │   ├── locals.scm
│   │   └── injections.scm
│   └── tests/
│       ├── common/
│       │   └── mod.rs   # Test utilities
│       ├── fixtures/
│       │   ├── valid/   # Valid .nx files
│       │   └── invalid/ # Files with errors
│       ├── snapshots/   # insta snapshots
│       └── parser_tests.rs
│
├── nx-hir/              # AST + semantic model
│   ├── Cargo.toml
│   ├── src/
│   │   ├── lib.rs       # Public API + unit tests
│   │   ├── ast/         # AST node definitions
│   │   │   ├── mod.rs
│   │   │   ├── expr.rs  # Expression nodes
│   │   │   ├── stmt.rs  # Statement nodes
│   │   │   └── types.rs # Type nodes
│   │   ├── lower.rs     # CST → AST lowering
│   │   └── db.rs        # Salsa database setup
│   └── tests/
│       └── lowering_tests.rs
│
└── nx-types/            # Type system + inference
    ├── Cargo.toml
    ├── src/
    │   ├── lib.rs       # Public API + unit tests
    │   ├── ty.rs        # Type representation
    │   ├── infer.rs     # Type inference engine
    │   ├── unify.rs     # Type unification
    │   └── primitives.rs # Primitive type definitions
    └── tests/
        ├── fixtures/
        │   └── type_examples.nx
        └── type_checker_tests.rs
```

**Structure Decision**: Multi-crate Rust workspace following rust-analyzer pattern. Separate crates enable parallel compilation, clear dependency boundaries, and independent testing. Dependency flow: nx-diagnostics (leaf) → nx-syntax → nx-hir → nx-types.

## Complexity Tracking

> No constitution violations. Table not required.

---

# Phase 0: Research & Technology Decisions

## Research Summary

All technical decisions are informed by the existing `nx-rust-plan.md` document and industry best practices from rust-analyzer, SWC, and tree-sitter ecosystem.

### Decision: Parser Technology

**Chosen**: tree-sitter v0.20+

**Rationale**:
- Industry standard for editor-grade parsing (VS Code, Neovim, Atom)
- Built-in incremental parsing for fast re-parsing
- Excellent error recovery - continues parsing after errors
- Mature query system for syntax highlighting
- Already integrated in existing `nx-syntax` crate

**Alternatives Considered**:
- **Custom hand-written parser**: Rejected - too much effort, no incremental parsing
- **Pest/Nom**: Rejected - less mature error recovery, no editor integration
- **LALRPOP**: Rejected - LR parsers poor for error recovery

### Decision: CST vs AST Strategy

**Chosen**: Dual-layer (tree-sitter CST + Rust HIR/AST)

**Rationale**:
- CST preserves everything (whitespace, comments) for tooling (formatter, LSP)
- AST simplifies semantic analysis and type checking
- Follows rust-analyzer proven architecture
- Avoids building custom cstree bridge (unproven approach)
- tree-sitter incremental parsing stays as source of truth

**Alternatives Considered**:
- **AST only**: Rejected - loses formatting information, poor for IDE features
- **CST only**: Rejected - too complex for type checking and semantic analysis
- **cstree/rowan bridge**: Rejected - unproven, adds complexity without clear benefit

### Decision: Incremental Computation

**Chosen**: Salsa v0.16+ (Phase 4 - Type Checking)

**Rationale**:
- Powers rust-analyzer's incremental analysis
- Query-based memoization - only recompute what changed
- Essential for coordinating parse → lower → type-check pipeline
- Integrates naturally with Rust's type system
- Mature, battle-tested in production

**Note for Phase 3 (Parsing Only)**:
- Tree-sitter has **built-in incremental parsing** - no Salsa needed
- Tree-sitter takes old tree, only re-parses changed regions
- Session API with Salsa deferred to Phase 4 when implementing full analysis pipeline
- Most tree-sitter parser implementations do NOT use Salsa (it's rust-analyzer specific)

**Alternatives Considered**:
- **No incremental**: Rejected - poor IDE performance, wastes computation
- **Custom caching**: Rejected - complex to implement correctly, reinventing wheel

### Decision: Error Reporting

**Chosen**: Ariadne v0.4

**Rationale**:
- Beautiful, modern diagnostic output with source context
- Better API than older codespan-reporting
- Supports ANSI colors and Unicode box-drawing
- Integrates well with text-size for source locations
- Actively maintained

**Alternatives Considered**:
- **codespan-reporting**: Rejected - older API, less ergonomic
- **Custom formatter**: Rejected - reinventing wheel, users expect modern output
- **miette**: Considered - good but Ariadne more focused on compiler errors

### Decision: Type Inference Strategy

**Chosen**: Local type inference (Hindley-Milner variant)

**Rationale**:
- Infer types for variables, expressions, function return types
- Require explicit function parameter types (reduce ambiguity)
- Standard approach in modern languages (Rust, TypeScript, Kotlin)
- Balances brevity with explicitness
- Specified in clarifications from spec

**Alternatives Considered**:
- **Explicit only**: Rejected - too verbose for users
- **Full inference**: Rejected - harder to debug, slower type checking

### Decision: Concurrency Model

**Chosen**: Thread-safe with `Send + Sync` types

**Rationale**:
- Enables parallel parsing of multiple files
- Rust's ownership prevents data races at compile time
- Salsa supports concurrent queries
- Required by spec (FR-008a)

**Alternatives Considered**:
- **Single-threaded**: Rejected - poor performance for batch operations
- **Async/await**: Deferred - not needed for library API, may add in future LSP

### Decision: Memory Management

**Chosen**: Arena allocation with `la-arena` for AST/HIR nodes

**Rationale**:
- Fast allocation/deallocation (batch free on drop)
- Stable references via arena indices
- Used by rust-analyzer successfully
- Keeps memory under 100MB target for 10k lines

**Alternatives Considered**:
- **Box/Rc for each node**: Rejected - memory overhead, fragmentation
- **Generational indices**: Considered - arena simpler for our use case

## Technology Stack Summary

| Component | Technology | Version | Purpose |
|-----------|-----------|---------|---------|
| **Parser** | tree-sitter | 0.20+ | CST generation, incremental parsing |
| **CST Wrappers** | Custom Rust types | N/A | Typed traversal over tree-sitter nodes |
| **Text Positions** | text-size | 1.1+ | Source location tracking |
| **Incremental** | salsa | 0.16+ | Query-based memoization |
| **Diagnostics** | ariadne | 0.4 | Beautiful error messages |
| **AST Storage** | la-arena | 0.3+ | Arena allocation for HIR nodes |
| **Small Strings** | smol_str | 0.2+ | Efficient string interning |
| **Hash Maps** | rustc-hash | 1.1+ | Fast hash functions |
| **Testing** | insta | 1.34+ | Snapshot regression tests |

---

# Phase 1: Design & Contracts

## Data Model

[See separate data-model.md file]

## API Contracts

[See contracts/library-api.md file]

## Quick Start Guide

[See quickstart.md file]

---

## Next Steps

1. **Review this plan** against spec requirements
2. **Run `/speckit.tasks`** to generate implementation tasks from this plan
3. **Begin implementation** following task order in tasks.md

---

**Plan Status**: ✅ Complete - Ready for task generation via `/speckit.tasks`
